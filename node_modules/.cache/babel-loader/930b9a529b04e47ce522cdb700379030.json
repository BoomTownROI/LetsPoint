{"ast":null,"code":"import _objectWithoutProperties from \"@babel/runtime-corejs2/helpers/esm/objectWithoutProperties\";\nimport _defineProperty from \"@babel/runtime-corejs2/helpers/esm/defineProperty\";\nimport _objectSpread from \"@babel/runtime-corejs2/helpers/esm/objectSpread\";\nimport _Promise from \"@babel/runtime-corejs2/core-js/promise\";\nimport _classCallCheck from \"@babel/runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime-corejs2/helpers/esm/createClass\";\nimport firebase from 'firebase/app';\nimport 'firebase/auth';\nimport 'firebase/firestore';\nimport 'firebase/functions';\nimport { byTimestamp } from 'utils/sorting';\nimport config from './env';\nimport { meetingFromSnap, ticketFromSnap, profileFromSnap } from 'schema';\n\nvar FirebaseService =\n/*#__PURE__*/\nfunction () {\n  function FirebaseService() {\n    _classCallCheck(this, FirebaseService);\n\n    try {\n      firebase.initializeApp(config);\n    } catch (err) {\n      // we skip the \"already exists\" message which is\n      // not an actual error when we're hot-reloading\n      if (!/already exists/.test(err.message)) {\n        console.error('Firebase initialization error', err.stack);\n      }\n    }\n\n    this.auth = firebase.auth();\n    this.db = firebase.firestore();\n    this.functions = firebase.functions();\n  }\n\n  _createClass(FirebaseService, [{\n    key: \"_getTimestamp\",\n    value: function _getTimestamp() {\n      return firebase.firestore.FieldValue.serverTimestamp();\n    }\n  }, {\n    key: \"signInWithGoogle\",\n    value: function signInWithGoogle() {\n      var provider = new firebase.auth.GoogleAuthProvider();\n      return this.auth.signInWithPopup(provider);\n    }\n  }, {\n    key: \"signInWithEmailAndPassword\",\n    value: function signInWithEmailAndPassword(email, password) {\n      var _this = this;\n\n      return this.auth.createUserWithEmailAndPassword(email, password).catch(function (err) {\n        if (err.code === 'auth/email-already-in-use') {\n          console.log('email in use, trying to sign in');\n          return _this.auth.signInWithEmailAndPassword(email, password).catch(function (reason) {\n            return console.warn(reason);\n          });\n        } else {\n          console.error('trouble creating a user', err);\n          throw err;\n        }\n      });\n    }\n  }, {\n    key: \"signOut\",\n    value: function signOut() {\n      return this.auth.signOut().catch(function (err) {\n        return console.error('error related to signing out', err);\n      });\n    }\n    /**\n     * Get a subscription to the user's list of meetings\n     * NOTE: OrderBy is applied client side to avoid needing an index for over specificity\n     */\n\n  }, {\n    key: \"onMeetingList\",\n    value: function onMeetingList(cb) {\n      var user = this.auth.currentUser;\n\n      if (user == null) {\n        console.error('Tried to call onMeetingList with no user');\n        return function noop() {};\n      }\n\n      return this.db.collection(\"/meetings\").where(\"participantIDs.\".concat(user.uid), '==', true).onSnapshot(function (querySnapshot) {\n        cb(querySnapshot.docs.map(meetingFromSnap).sort(function (a, b) {\n          return byTimestamp(a.createdAt, b.createdAt);\n        }));\n      });\n    }\n  }, {\n    key: \"onMeeting\",\n    value: function onMeeting(mid, cb) {\n      return this.db.doc(\"/meetings/\".concat(mid)).onSnapshot(function (snap) {\n        if (false === snap.exists) return cb(false);\n        cb(meetingFromSnap(snap));\n      });\n    }\n  }, {\n    key: \"createMeeting\",\n    value: function createMeeting(meeting) {\n      var user = this.auth.currentUser;\n\n      if (user == null) {\n        return _Promise.reject('Tried to call createMeeting with no user');\n      }\n\n      var m = _objectSpread({}, meeting, {\n        participantIDs: _defineProperty({}, user.uid, true),\n        participantData: _defineProperty({}, user.uid, {\n          displayName: user.displayName || '',\n          photoURL: user.photoURL || ''\n        }),\n        // @ts-ignore\n        createdAt: this._getTimestamp()\n      });\n\n      return this.db.collection(\"/meetings\").add(m);\n    }\n  }, {\n    key: \"updateMeeting\",\n    value: function updateMeeting(_ref) {\n      var id = _ref.id,\n          rest = _objectWithoutProperties(_ref, [\"id\"]);\n\n      var user = this.auth.currentUser;\n\n      if (user == null) {\n        return _Promise.reject('Tried to call createMeeting with no user');\n      }\n\n      if (!id) return _Promise.reject('Tried updating a meeting without an id');\n      return this.db.doc(\"/meetings/\".concat(id)).update(_objectSpread({}, rest));\n    }\n  }, {\n    key: \"getArchivedMeetingList\",\n    value: function getArchivedMeetingList() {\n      var user = this.auth.currentUser;\n\n      if (user == null) {\n        return _Promise.reject('User noth authorized');\n      }\n\n      return this.db.collection(\"/archivedMeetings\").where(\"participantIDs.\".concat(user.uid), '==', true).get().then(function (data) {\n        return data.docs.map(meetingFromSnap).sort(function (a, b) {\n          return byTimestamp(a.createdAt, b.createdAt);\n        });\n      });\n    }\n  }, {\n    key: \"archiveMeeting\",\n    value: function archiveMeeting(mid, to) {\n      var user = this.auth.currentUser;\n\n      if (user == null) {\n        return _Promise.reject('Tried to call createMeeting with no user');\n      }\n\n      return this.functions.httpsCallable('archiveMeeting')({\n        mid: mid,\n        to: to\n      });\n    }\n  }, {\n    key: \"addSelfToMeeting\",\n    value: function addSelfToMeeting(mid) {\n      var _this$db$doc$update;\n\n      var user = this.auth.currentUser;\n\n      if (user == null) {\n        console.error('Tried to call addSelfToMeeting with no user');\n        return;\n      }\n\n      return this.db.doc(\"/meetings/\".concat(mid)).update((_this$db$doc$update = {}, _defineProperty(_this$db$doc$update, \"participantIDs.\".concat(user.uid), true), _defineProperty(_this$db$doc$update, \"participantData.\".concat(user.uid), {\n        displayName: user.displayName,\n        photoURL: user.photoURL\n      }), _this$db$doc$update));\n    }\n  }, {\n    key: \"addUserToObserverList\",\n    value: function addUserToObserverList(mid, uid) {\n      return this._updateUserInObserverList(mid, uid, true);\n    }\n  }, {\n    key: \"removeUserFromObserverList\",\n    value: function removeUserFromObserverList(mid, uid) {\n      return this._updateUserInObserverList(mid, uid, firebase.firestore.FieldValue.delete());\n    }\n  }, {\n    key: \"_updateUserInObserverList\",\n    value: function _updateUserInObserverList(mid, uid, value) {\n      return this.db.doc(\"/meetings/\".concat(mid)).update(_defineProperty({}, \"observerIDs.\".concat(uid), value));\n    }\n    /**\n     * Ordering is done on the server\n     */\n\n  }, {\n    key: \"onTicketList\",\n    value: function onTicketList(mid, cb) {\n      return this.db.collection(\"/meetings/\".concat(mid, \"/tickets\")).orderBy('createdAt').onSnapshot(function (querySnapshot) {\n        cb(querySnapshot.docs.map(ticketFromSnap));\n      });\n    }\n  }, {\n    key: \"createTicket\",\n    value: function createTicket(mid, ticket) {\n      var t = {\n        title: ticket.title,\n        link: ticket.link || '',\n        description: ticket.description || '',\n        votes: {},\n        isRevealed: false,\n        // @ts-ignore\n        createdAt: this._getTimestamp()\n      };\n      return this.db.collection(\"/meetings/\".concat(mid, \"/tickets\")).add(t);\n    }\n  }, {\n    key: \"updateTicket\",\n    value: function updateTicket(mid, ticket) {\n      var id = ticket.id,\n          rest = _objectWithoutProperties(ticket, [\"id\"]);\n\n      if (!id) {\n        return _Promise.reject('Must provide ticket id');\n      }\n\n      return this.db.doc(\"/meetings/\".concat(mid, \"/tickets/\").concat(id)).update(rest);\n    }\n  }, {\n    key: \"voteOnTicket\",\n    value: function voteOnTicket(mid, tid, vote) {\n      var user = this.auth.currentUser;\n      if (user === null) return _Promise.reject('User not logged in');\n      return this._ticket(mid, tid).update(_defineProperty({}, \"votes.\".concat(user.uid), vote));\n    }\n  }, {\n    key: \"revealTicket\",\n    value: function revealTicket(mid, tid) {\n      return this._ticket(mid, tid).update({\n        isRevealed: true\n      });\n    }\n  }, {\n    key: \"deleteTicket\",\n    value: function deleteTicket(mid, tid) {\n      return this._ticket(mid, tid).delete();\n    }\n  }, {\n    key: \"_ticket\",\n    value: function _ticket(mid, tid) {\n      return this.db.doc(\"/meetings/\".concat(mid, \"/tickets/\").concat(tid));\n    }\n  }, {\n    key: \"createCredentials\",\n    value: function createCredentials(_ref2) {\n      var url = _ref2.url,\n          username = _ref2.username,\n          password = _ref2.password;\n      var user = this.auth.currentUser;\n      if (user === null) return _Promise.reject('User not logged in');\n      var credForDB = {\n        url: url,\n        token: btoa(\"\".concat(username, \":\").concat(password)),\n        storyPointField: '' // TODO: Automate this\n\n      }; // Setting a fixed doc ID for now, if we want to add more credentials then\n      // it makes sense to do more here\n\n      var profileRef = this.db.doc(\"/profiles/\".concat(user.uid));\n      var jiraRef = this.db.doc(\"/profiles/\".concat(user.uid, \"/secure/jira\"));\n      var b = this.db.batch();\n      b.set(profileRef, {\n        hasCreds: true\n      }, {\n        merge: true\n      });\n      b.set(jiraRef, credForDB);\n      return b.commit();\n    }\n  }, {\n    key: \"onProfile\",\n    value: function onProfile(cb) {\n      var user = this.auth.currentUser;\n\n      if (user === null) {\n        console.error('trying to call onProfile with no user');\n        return function noop() {};\n      }\n\n      return this._profile(user.uid).onSnapshot(function (snap) {\n        cb(profileFromSnap(snap));\n      });\n    }\n  }, {\n    key: \"getProfile\",\n    value: function getProfile() {\n      var user = this.auth.currentUser;\n      if (user === null) return _Promise.reject('User not logged in');\n      return this._profile(user.uid).get().then(profileFromSnap);\n    }\n  }, {\n    key: \"_profile\",\n    value: function _profile(uid) {\n      return this.db.doc(\"/profiles/\".concat(uid));\n    }\n  }, {\n    key: \"importTicketFromJiraTID\",\n    value: function importTicketFromJiraTID(mid, tid) {\n      return this.functions.httpsCallable('fetchTickets')({\n        tid: tid,\n        mid: mid\n      });\n    }\n  }, {\n    key: \"pushPointsToJira\",\n    value: function pushPointsToJira(ticketUpdates) {\n      return this.functions.httpsCallable('pushPointsToJira')({\n        ticketUpdates: ticketUpdates\n      });\n    }\n  }]);\n\n  return FirebaseService;\n}();\n\nexport default new FirebaseService();","map":null,"metadata":{},"sourceType":"module"}